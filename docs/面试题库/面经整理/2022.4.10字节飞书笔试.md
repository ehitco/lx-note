#  2022.4.10字节飞书笔试

- css优先级：当存在更高优先级的选择器时，选择更高的；优先级一样，选择后面定义的，与html中class的书写顺序无关

```html
<style>
	.a{
	  color:orange;
	}
	.b{
	  color:red;
	}
	.c{
	  color:yellow;
	}
	.a.b{
	  color:blue;
	}
	.b.a{
	  color:green;
	}
</style>
<div class="a b">text1</div>  // green
<div class="b c">text2</div> // yellow
<div class="c b">text3</div> // yellow
<div class="b a">text4</div> // green
```

- PWA技术构成
	- 特点
		- 渐进式：以渐进式增强作为核心宗旨来开发的
			- 渐进式是指：提供的功能可以用也可以不用，不要求一次性接受所有的功能。
		- 自适应：适用于任何机型
		- 连接无关系：基于server worker实现在离线或低质量的网络环境下使用。
		- 离线推送：使用推送消息通知，可以像原生app一样，提升用户体验
		- 及时更新：可以基于server worker更新保持状态最新
		- 安全性：基于HTTPS，以防止窥探和确保内容不被篡改
	- 主要技术：Server worker、Notification、App Mainfest等
- CSS权重计算和判断
- HTTP2的特性
- 前端安全相关配置和设置
	- 错误的做法
		- 提交数据使用get（get和post的区别）
		- 为AJAX请求添加失败自动尝试的逻辑
		- 处理跨域`allow-origin`为*（后端跨域设置）
- 硬币问题：区分26枚硬币，里面有一枚是次品（较轻），至少需要多少次称量
	- 第一次：8、9、9
	- 第二次：3、3、3
	- 第三次：1、1、1
- 应用设计中的局部性原理
- 单页面应用的优点
	- 优点
		- 前端可以自行维护路由和页面展示的逻辑，每次页面改动不需要通知服务器。
		- 更好的交互体验，不用每次都从服务器拉取数据，可以快速的展示给用户
	- 缺点
		- 不利于SEO
		- 不利于服务端渲染
		- 首次加载慢
- 正则表达式匹配
- CSS优先级顺序
	- !important > 行内样式 > ID选择器 > 类选择器 | 属性选择器 | 伪类选择器 > 元素选择器
- 事件机制——捕获和冒泡
- 浏览器执行js
	- 请求处理是宏任务，不会阻塞js执行
	- 当js中内存无法被正常回收，就会出现内存泄漏
	- js是单线程的
	- 死循环会阻塞js执行
- 数据库相关
	- 为数据库添加索引可以加快对表记录的**查找或排序**，但会增加存储空间，而且**插入和修改**会花费更多时间（因为索引也要随之变动）
	- 有序索引通常使用B+树实现
	- 对修改性能需求高的，不应该创建索引
	- 哈希索引查询比有序索引更快
- typeof返回值（7种）
	- number、boolean、string、undefined、object、function、symbol
	- 没有array和null，都是object
- JSON.parse(JSON.stringify(obj))局限性（[参考](https://github.com/Yuanfang-fe/Blog-X/issues/14)）
	- 对于function、undefined、symbol
		- 在非数组对象中会被忽略（包括属性名）
		- 在数组中会被转化为null（保证单元位置不变）
	- 时间对象会变为字符串
	- RegExp、Error对象变为空对象
	- NaN、Infinity、-Infinity变为null
	- 只能序列化可枚举的自有属性
	- 存在对象循环引用会报错
	- 抛弃对象的constructor，变为Object
- 算法题（两道）
	- 第一题
		- 有一个矩阵，矩阵中每个数字代表一块海洋/土地块（数字1代表土地，数字0代表海洋），每块土地仅与上下左右四块其他的土地块/海洋接壤。矩阵边缘以外均视为土地。涨潮时，与海洋接壤两格或以上的土地块将被淹没为海洋。请返回涨潮后的矩阵。
		- ![](https://cdn.jsdelivr.net/gh/Merlin218/image-storage/picGo/202204131732419.png)
		- 思路
			- 遍历一次记录土地位置，用对象或数组存储
			- 对土地进行判断，满足上下左右四个方向有两个以上是海洋，修改矩阵（坑点：需要对矩阵进行拷贝，不能直接修改原矩阵，会影响结果）
	- 第二道
		- 小明设计了一个简单的机器人，它每移动一步至少需要消耗一个能量值。例如当小明给它输入5个能量值的时候，它可能会走0步（也就是不动），也可能走1步，但是不会走超过5步。
		- 小明希望机器人往前走 N 步，每个位置有不同的能量值，每次消耗了能量值之后可以往前走几步，到达新的位置之后。可以继续消耗当前位置的能量值。继续往前。如果当前位置的能量值为0，那么机器人就无法行动了。
		- 小明现在的疑惑是，机器人是否有机会移动到最后一个指令，你可以帮他计算一下吗？
		- 输入：第一行n表示位置数量；第二行表示每个位置的能量值
		- 输出：TRUE或FALSE
		- 样例：
			- 5(换行)2 3 1 1 4
			- 输出：TRUE
			- 解释：第一个能量位是 2，但是机器人可以先走1步，从下标0 到达下标1，然后再从下标1 走3 步到选最后一个指令。
		- 思路
			- 

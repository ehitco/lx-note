# 不同的二叉搜索树

[力扣题目链接(opens new window)](https://leetcode.cn/problems/unique-binary-search-trees/)

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

![](https://img-blog.csdnimg.cn/20210113161941835.png)

## 思路

dp数组：节点数位n的二叉搜索树的个数

![](https://cdn.jsdelivr.net/gh/Merlin218/image-storage/picGo/202207172145536.png)

![](https://cdn.jsdelivr.net/gh/Merlin218/image-storage/picGo/202207172219838.png)
来看看n为3的时候，有哪几种情况。

当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，和 n 为2的时候两棵树的布局是一样的。

当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，和n为2的时候两棵树的布局也是一样的。

当2为头结点的时候，其左右子树都只有一个节点，和n为1的时候只有一棵树的布局也是一样的。

发现到这里，其实我们就找到了重叠子问题了，其实也就是发现可以通过dp[1] 和 dp[2] 来推导出来dp[3]的某种方式。

所以，dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

## 代码

```js
var numTrees = function(n) {
    let dp = new Array(n + 1).fill(0);
    dp[0] = 1;
    for(let i = 1; i <= n; i++){
        for(let j = 1; j <= i; j++){
            // 表示以j为头结点时，左子树的数量 * 右子树的数量
            dp[i] += dp[j - 1] * dp[i - j];
        }
    }
    return dp[n];
};
```
# HTTP详解

## 什么是HTTP

HTTP是超文本传输协议（`HyperText Transfer Protocol`）

- 协议
	- HTTP协议，我们可以认为是一个用在计算机世界里的协议，建立了一种计算机之间交流通信的**规范**，以及相关的各种控制和错误的处理方式。
- 传输
	- HTTP是一个双向协议，当我们在网上🏄🏻时，浏览器是请求方，百度是应答方，两者约定通过HTTP协议来通信，于是浏览器把请求信息发送给网站服务器，网站服务器再把一些数据返回给浏览器，来实现一次通信。
	- 数据在两边传输，但也允许中间有中转或者接力。中间人遵循HTTP协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。
- 超文本
	- 文本：互联网早期只是简单的字符文字，现在已经扩展为图片、视频、压缩包等
	- 超文本：文字、图片、视频的混合体，**最关键是有超链接**，能从一个超文本跳转到另外一个超文本。
	- HTML就是常见的超文本

总的来说， **HTTP 是一个在计算机世界里专⻔在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和 规范」。**

## 常见的HTTP状态码

[HTTP常见状态码](常见的状态码.md)

## 常见的HTTP字段
- Host
	- 指定服务器的域名
	- Host: www.A.com
- Content-Length
	- 服务器返回数据时，会有该字段，表示数据的长度
	- Content-Length: 1000
- Connection
	- 客户端要求服务器使用TCP持久连接，以便其他请求复用，HTTP/1.1 版本的默认连接都是持久连接
	- 为了兼容老版本的 HTTP，需要指定 Connection: Keep-Alive
- Content-Type
	- 用于服务器回应时，告诉客户端，本次数据是什么格式。
	- Content-Type: text/html; charset=utf-8
- Accept
	- 客户端请求时，可以设定`Accept`字段表示接受哪些数据格式；
	- Accept: `*/*`
- Content-Encoding
	- 数据的压缩方法。表示服务器返回的数据使用了什么压缩格式
	- Content-Encoding: gzip
- Accept-Encoding: gzip,deflate

## GET与POST

- 两者区别
	- GET是请求从服务器获取资源
	- POST是请求向URL指定的资源提交数据，数据放在body中
- 两者是否都是安全幂等的
	- 安全：请求方法不会破坏服务器上的资源
	- 幂等：执行多次相同的操作，结果都是相同的
	- GET方法是安全且幂等的
	- POST方法，会修改服务器上的资源，使用不安全，多次提交数据会创建多个资源，所以不是幂等的

## HTTP特性

### 优点
1. 简单

HTTP基本的报文格式就是`header & body`，头部信息也是`key:value`的形式，易于理解，降
低了学习和使用的门槛。

2. 灵活和易于扩展

HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。

同时HTTP工作在应用层，则它下层可以随意变化。

HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC。

3. 应用广泛和跨平台

### 缺点

1. 无状态——双刃剑

好处：服务器不会去记录HTTP的状态，所以不需要额外的资源来记录状态信息，减轻服务器的负担

坏处：没有记忆功能，在完成有关联性的操作时会非常麻烦

> **使用cookie控制客户端状态**
> - 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。
> - 在客户端第一次请求后，服务器会下发一个装有客户信息的cookie，后续客户端请求服务器的时候，带上cookie，服务器就能认得了。

2. 明文传输——双刃剑

明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。

但也意味着所有信息都可以被查看，很容易被窃取。

3. 不安全（最大的问题）
- 通信使用明文(不加密)，内容可能会被窃听。
- 不验证通信方的身份，因此有可能遭遇伪装。
- 无法证明报文的完整性，所以有可能已遭篡改。

HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。

### HTTP/1.1性能

HTTP协议基于TCP/IP，并且使用了「请求-应答」的通信方式

1. 长连接

HTTP/1.1提出了`长连接`的通信方式，也叫持久连接，好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

只要没有任意一段明确提出断开连接，则保持TCP连接状态。

2. 管道网络传输

HTTP/1.1 采用了⻓连接的方式，这使得管道(pipeline)网络传输成为了可能。

即可在同个TCP连接里面，客户端可以发送多个请求，只要第一个请求发出去了，就可以接着发送第二个请求，可以**减少整体的响应时间**。

但服务器还是得按顺序，但前面的回应特别慢，后面的就会需要排队等待，称队头堵塞。

3. 队头阻塞

「请求 - 应答」的模式加剧了 HTTP 的性能问题。

因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会导致客户端一直请求不到数据，这也就是「`队头阻塞`」。

总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。

### 如何优化HTTP/1.1

- 使用KeepAlive将HTTP/1.1从短连接改为长连接。
	- 从底层的传输层入手，通过减少TCP的连接建立和断开的次数，来减网络传输的延迟，从而提高HTTP/1.1协议的传输效率。
- 其他优化思路
	- 尽量避免发送HTTP请求
	- 在需要发送HTTP请求时，尽量减少请求次数
	- 减少服务器HTTP响应的数据大小

#### 如何避免发送HTTP请求

通过缓存机制来优化。

- 对于重复性的HTTP请求，如果每次请求的到的数据一致，我们就把这对「请求-响应」的数据缓存在本地，那么下次就直接读取本地的数据。

[#浏览器缓存机制](../浏览器/缓存机制.md)

客户端会把第一次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，而响应作为 value，两者形成映射关系。

这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就直接从本地读取该响应。

另外，服务器在发送HTTP响应式，会估算一个过期的时间，并把这个信息放在响应头部中，这样客户端查找头部信息的时候，一旦发现缓存已经过期们就会重新发送请求：
- 如果服务器上的资源没有改变（可以通过`Etag`判断），服务器仅返回不包含body的`304`响应，来减少响应资源在网络中传输的时延；
- 如果资源发生了更新，响应中就会带上最新的资源，返回正常的`200`响应。

#### 如何减少HTTP请求次数

##### 减少重定向次数

服务器上的一个资源可能由于迁移、维护等原因从 url1 移至 url2 后，而客户端不知情，它还是继续请求 url1，这时服务器通过 302 响应码和 Location 头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。

如果重定向请求越多，那么客户端就要多次发起 HTTP 请求，每一次的 HTTP 请求都得经过网络，这无疑会越降低网络性能。

![](https://raw.githubusercontent.com/Merlin218/image-storage/master/picGo/202203171505020.png)

如果我们可以把重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了。

![](https://raw.githubusercontent.com/Merlin218/image-storage/master/picGo/202203171506249.png)

而且当代理服务器知晓了重定向规则后，可以进一步减少消息传递次数：

![](https://raw.githubusercontent.com/Merlin218/image-storage/master/picGo/202203171507630.png)

其他的重定向状态码：

![](https://raw.githubusercontent.com/Merlin218/image-storage/master/picGo/202203171508959.png)

其中， 301 和 308 响应码是告诉客户端可以将重定向响应缓存到本地磁盘，之后客户端就自动用 url2 替代 url1 访问服务器的资源。

##### 合并请求

如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源时一样的，但**减少了重复发送的HTTP头部**。

由于HTTP/1.1是请求响应模型，如果第一个请求未得到响应，则后续的请求也不会发送。于是浏览器为了防止单个请求的阻塞，使用一般会同时发起5-6个请求，**每个请求都是不同的TCP连接**，那么如果合并了请求，就可以**减少TCP连接的数量，也就省去了TCP握手和慢启动过程消耗的时间**。

- 几种合并请求的方式
	- 使用`CSS Image Sprites`技术把小图合并成一张大图，浏览器可以一次请求到一个发图片，再根据CSS数据把大图切割成小图
	- 使用`Webpack`将资源合并打包成大文件
	- 图片可以使用base64编码嵌入到html文件中

##### 延迟发送请求

- 对于不需要的资源，可以不用一下子都获取，可以通过按需获取的方式，减少第一时间的HTTP请求次数。
- 可以只获取用户当前所看到的的页面资源，当用户向下滑动时，再向服务器获取接下来的资源。

#### 如何减少HTTP响应的数据大小

对数据包进行压缩
- 无损压缩
	- 常用的有`gzip`
	- 通过请求头部`accept-coding`和响应头部`content-encoding`字段来识别压缩算法
- 有损压缩
	- 通常用在压缩多媒体数据，例如音频、视频、图片
	- 可以通过 HTTP 请求头部中的 Accept 字段里的`q 质量因子`，告诉服务器期望的资源质量
	- 常用的编码格式
		- 图片：jpg、png、webp（压缩率高）
		- 视频：h264、h265
		- 音频：acc、ac3

#### 总结

优化 HTTP/1.1 协议的思路：

第一个思路是，通过缓存技术来避免发送 HTTP 请求。

客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。

第二个思路是，减少 HTTP 请求的次数，有以下的方法:

1. 将原本由客户端处理的􏰁定向请求，交给代理服务器处理，这样可以减少􏰁定向请求的次数;
    
2. 将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗;
    
3. 按需访问资源，只访问当前用户看得到/用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。
    

第三思路是，通过压缩响应资源，降低传输资源的大小，从而提高传输效率，所以应当选择更优秀的压缩算法。 


